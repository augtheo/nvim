{
	"A matrix of size nxm": {
		"prefix": "mat",
		"body": [
			"int ${1:n} , ${2:m};",
			"cin>>${1:n}>>${2:m};",
			"vector<vector<${3:int}> > ${4:mat}(${1:n} , vector<${3:int}> (${2:m}));",
			"for(int i = 0 ; i < ${1:n} ; i++)",
			"    for(int j = 0 ; j < ${1:m} ; j++)",
			"        cin>>${4:mat}[i][j];",
			"$5"
		],
		"description": "A matrix of size nxm"
	},
  "Base": {
  "prefix": "base",
  "body": [
    "#include <bits/stdc++.h>",
    "#include <ext/pb_ds/assoc_container.hpp>",
    "#include <ext/pb_ds/tree_policy.hpp>",
    " ",
    "using namespace std;",
    "using namespace __gnu_pbds;",
    " ",
    "using ll = long long;",
    "using ld = long double;",
    "template <typename T>",
    "using orderedSet = tree<T, null_type, less<T>, rb_tree_tag, tree_order_statistics_node_update>;",
    "template <typename T>",
    "using orderedMultiset = tree<T, null_type, less_equal<T>, rb_tree_tag, tree_order_statistics_node_update>;",
    " ",
    "const ld pi = 4.0 * atan(1.0);",
    "#define xlr8                          \\",
    "    ios_base::sync_with_stdio(false); \\",
    "    cin.tie(NULL);                    \\",
    "    cout.tie(NULL);                   \\",
    "    cout.precision(10);               \\",
    "    cout << fixed",
    " ",
    "//76149",
    "template <int D, typename T>",
    "struct Vec : public vector<Vec<D - 1, T>>",
    "{",
    "    static_assert(D >= 1, \"Vector dimension must be greater than zero!\");",
    "    template <typename... Args>",
    "    Vec(int n = 0, Args... args) : vector<Vec<D - 1, T>>(n, Vec<D - 1, T>(args...))",
    "    {",
    "    }",
    "};",
    "template <typename T>",
    "struct Vec<1, T> : public vector<T>",
    "{",
    "    Vec(int n = 0, T val = T()) : vector<T>(n, val)",
    "    {",
    "    }",
    "};",
    "",
    "//68809",
    "void __print(int x) {cerr << x;}",
    "void __print(long x) {cerr << x;}",
    "void __print(long long x) {cerr << x;}",
    "void __print(unsigned x) {cerr << x;}",
    "void __print(unsigned long x) {cerr << x;}",
    "void __print(unsigned long long x) {cerr << x;}",
    "void __print(float x) {cerr << x;}",
    "void __print(double x) {cerr << x;}",
    "void __print(long double x) {cerr << x;}",
    "void __print(char x) {cerr << '\\'' << x << '\\'';}",
    "void __print(const char *x) {cerr << '\\\"' << x << '\\\"';}",
    "void __print(const string &x) {cerr << '\\\"' << x << '\\\"';}",
    "void __print(bool x) {cerr << (x ? \"true\" : \"false\");}",
    "",
    "template<typename T, typename V>",
    "void __print(const pair<T, V> &x) {cerr << '{'; __print(x.first); cerr << ','; __print(x.second); cerr << '}';}",
    "template<typename T>",
    "void __print(const T &x) {int f = 0; cerr << '{'; for (auto &i: x) cerr << (f++ ? \",\" : \"\"), __print(i); cerr << \"}\";}",
    "void _print() {cerr << \"]\\n\";}",
    "template <typename T, typename... V>",
    "void _print(T t, V... v) {__print(t); if (sizeof...(v)) cerr << \", \"; _print(v...);}",
    "#ifndef ONLINE_JUDGE",
    "#define debug(x...) cerr << \"[\" << #x << \"] = [\"; _print(x)",
    "#else",
    "#define debug(x...)",
    "#endif",
    "",
    "",
    "void solve()",
    "{",
    "  ${1}",
    "}",
    "",
    "int main()",
    "{",
    "    xlr8;",
    "    int testCases = 1;",
    "    cin >> testCases;",
    "    for(int t = 1; t <= testCases; t++)",
    "    {",
    "      solve();",
    "    }",
    "}",
    ""
  ],
  "description": "Base"
},
	"Disjoint Sets": {
		"prefix": "dsu",
		"body": [
			"struct DisjointSets",
			"{",
			"    int n;",
			"    vector<int> parent, rank, sz;",
			"    DisjointSets(int n)",
			"    {",
			"        this->n = n;",
			"        parent.resize(n+1,0);",
			"        iota(parent.begin(), parent.end(), 0);",
			"        rank.resize(n+1,1);",
			"        sz.resize(n+1, 1);",
			"    }",
			"    int find(int i)",
			"    {",
			"        if(i!=parent[i])",
			"            parent[i] = find(parent[i]);",
			"        return parent[i];",
			"    }",
			"    void UnionByRank(int i , int j)",
			"    {",
			"        i = find(i);j = find(j);",
			"        if(i==j)    return;",
			"        if(rank[i]<rank[j])",
			"            swap(i,j);",
			"        parent[j] = i;",
			"        rank[i]+=rank[j];",
			"        sz[i] += sz[j];",
			"    }",
			"    void UnionBySize(int i ,int j)",
			"    {",
			"        i = find(i);j = find(j);",
			"        if(i==j)    return;",
			"        if(sz[i] < sz[j])",
			"            swap(i,j);",
			"        parent[j] = i;",
			"        sz[i]+=sz[j];",
			"        rank[i] += rank[j];",
			"    }",
			"",
			"    void solve()",
			"    {",
			"    }",
			"};"
		],
		"description": "Disjoint Set Datastructure"
	},
	"Binary Exponentiation": {
		"prefix": "binpow",
		"body": [
			"ll binpow(ll x, ll n,ll mod = MOD )",
			"{",
			"\tll ans =1;",
			"\tx = x%mod;",
			"\twhile(n>=1)",
			"\t{",
			"\t\tif(n&1)",
			"\t\t\tans=(ans*x)%mod;",
			"\t\tx=(x*x)%mod;",
			"\t\tn>>=1;",
			"\t}",
			"\treturn ans;",
			"}"
		],
		"description": "Algorithm to exponentiate efficiently"
	},
  "Graph": {
  "prefix": "graph",
  "body": [
    "struct Graph",
    "{",
    "  int n;",
    "  vector<vector<int> > adj;",
    "  Graph(int n)",
    "  {",
    "    this->n = n;",
    "    adj.resize(n +  1);",
    "  }",
    "  void addEdge(int u , int v)",
    "  {",
    "    adj[u].push_back(v);",
    "    adj[v].push_back(u);",
    "  }",
    "  void dfs(int u , int p )",
    "  {",
    "    for(auto v : adj[u])",
    "    {",
    "      if(v!= p)",
    "      {",
    "        dfs(v , u);",
    "      }",
    "    }",
    "  }",
    "  void solve()",
    "  {",
    "    dfs(1, - 1);",
    "  }",
    "};",
    ""
  ],
  "description": "Graph"
},
  "SieveEratosthenes": {
  "prefix": "sieve-eratosthenes",
  "body": [
    "template<typename T>",
    "class SieveEratosthenes",
    "{",
    "  public:",
    "    vector<T> primes;",
    "    vector<bool> is_prime;",
    "    SieveEratosthenes(int MAX = 1000000)",
    "    {",
    "      is_prime.resize(MAX + 1, true);",
    "      is_prime[0] = is_prime[1] = false;",
    "      for(ll i = 2; i*i<=MAX; i++)",
    "        if(is_prime[i])",
    "          for(ll j = i*i; j<=MAX; j+=i)",
    "            is_prime[j] = false;",
    "      for(ll i =2; i<=MAX; i++)",
    "        if(is_prime[i])",
    "          primes.push_back(i);",
    "    }",
    "};",
    ""
  ],
  "description": "SieveEratosthenes"
},
	"SieveEuler": {
		"prefix": "sieve-euler",
		"body": [
			"",
			"template<typename T>",
			"struct SieveEuler",
			"{",
			"    vector<T> primes , lp , cnt;",
			"    void SieveEuler(int MAX = 1000000)",
			"    {",
			"        lp.resize(MAX + 1, 0) , cnt.resize(MAX + 1, 0);",
			"        for(ll i = 2; i<= MAX; i++)",
			"        {",
			"            if(lp[i] == 0)",
			"                {",
			"                    lp[i] = i , cnt[i] = 1;",
			"                    primes.push_back(i);",
			"                }",
			"            for(int j = 0; j< primes.size() && i*primes[j] <= MAX && primes[j]<= lp[i]; ++j)",
			"                {",
			"                    if(primes[j] == lp[i])",
			"                        lp[i*primes[j]]  = primes[j] ,cnt[i*primes[j]] = cnt[i] + 1;",
			"                    else ",
			"                        lp[i*primes[j]]  = primes[j] ,cnt[i*primes[j]] = 1;",
			"                }",
			"        }",
			"    }",
			"};"
		],
		"description": "Build the prime sieve in O(n). Used also for computing multiplicative functions."
	},
	"LCA": {
		"prefix": "lca",
		"body": [
			"struct LCA {",
			"    vector<int> height, euler, first, segtree , sz , parent;",
			"    vector<bool> visited;",
			"    int n;",
			" ",
			"    LCA(vector<vector<int>> &adj, int root = 0) {",
			"        n = adj.size();",
			"        height.resize(n);",
			"        first.resize(n);",
			"        sz.resize(n);",
			"        parent.resize(n, -1);",
			"        euler.reserve(n * 2);",
			"        visited.assign(n, false);",
			"        dfs(adj, root);",
			"        int m = euler.size();",
			"        segtree.resize(m * 4);",
			"        build(1, 0, m - 1);",
			"    }",
			" ",
			"    void dfs(vector<vector<int>> &adj, int node, int h = 0) {",
			"        visited[node] = true;",
			"        height[node] = h;",
			"        sz[node] = 1;",
			"        first[node] = euler.size();",
			"        euler.push_back(node);",
			"        for (auto to : adj[node]) ",
			"        {",
			"            if (!visited[to]) ",
			"            {",
			"                parent[to] = node;",
			"                dfs(adj, to, h + 1);",
			"                sz[node] += sz[to];",
			"                euler.push_back(node);",
			"            }",
			"        }",
			"    }",
			" ",
			"    void build(int node, int b, int e) {",
			"        if (b == e) {",
			"            segtree[node] = euler[b];",
			"        } else {",
			"            int mid = (b + e) / 2;",
			"            build(node << 1, b, mid);",
			"            build(node << 1 | 1, mid + 1, e);",
			"            int l = segtree[node << 1], r = segtree[node << 1 | 1];",
			"            segtree[node] = (height[l] < height[r]) ? l : r;",
			"        }",
			"    }",
			" ",
			"    int query(int node, int b, int e, int L, int R) {",
			"        if (b > R || e < L)",
			"            return -1;",
			"        if (b >= L && e <= R)",
			"            return segtree[node];",
			"        int mid = (b + e) >> 1;",
			" ",
			"        int left = query(node << 1, b, mid, L, R);",
			"        int right = query(node << 1 | 1, mid + 1, e, L, R);",
			"        if (left == -1) return right;",
			"        if (right == -1) return left;",
			"        return height[left] < height[right] ? left : right;",
			"    }",
			" ",
			"    int lca(int u, int v) {",
			"        int left = first[u], right = first[v];",
			"        if (left > right)",
			"            swap(left, right);",
			"        return query(1, 0, euler.size() - 1, left, right);",
			"    }"
		]
	},
  "ZFunction": {
  "prefix": "zfunc",
  "body": [
    "vector<int> z_function(string& s)",
    "{",
    "    int n = s.length();",
    "    vector<int> z(n, 0);",
    "    for(int i = 1 , l = 0  , r = 0; i < n ; i++)",
    "    {",
    "        if(i<= r)",
    "            z[i] = min(z[i - l ] , r - i + 1);",
    "        while(i + z[i] < n && s[i + z[i]] == s[z[i]])",
    "            ++z[i];",
    "        if(i + z[i] - 1 > r)",
    "            l = i , r = i + z[i] - 1;",
    "    }",
    "    return z;",
    "}",
    ""
  ],
  "description": "ZFunction"
},
  "SegmentTree": {
  "prefix": "seg",
  "body": [
    "template<typename T>",
    "class SegmentTree",
    "{",
    "  public:",
    "  vector<T> t;",
    "  int n, H;",
    "  void init(int n)",
    "  {",
    "    this->n = n;",
    "    t.resize(2*n);",
    "    this->H = sizeof(int)*8 - __builtin_clz(n);",
    "  }",
    "  void build()",
    "  {",
    "    for(int i = n-1; i>0;i--)",
    "      t[i] = t[i<<1] + t[(i<<1)|1];",
    "  }",
    "  void update(int pos, T val)",
    "  {",
    "    for(t[pos+=n]+= val ; pos>1;pos>>=1)",
    "      t[pos>>1] = t[pos] + t[pos^1];",
    "  }",
    "  T  query(int l, int r)",
    "  {",
    "    T res =0;",
    "    for(l+=n,r+=n;l<r;l>>=1,r>>=1)",
    "    {",
    "      if(l&1)     res+=t[l++];",
    "      if(r&1)     res+=t[--r];",
    "    }",
    "    return res;",
    "  }",
    "};",
    ""
  ],
  "description": "SegmentTree"
},
  "Factorial": {
  "prefix": "fact",
  "body": [
    "vector<ll> fact, ifact;",
    "void buildFact(int N , ll mod = MOD)",
    "{",
    "    fact.resize(N + 1 ) , ifact.resize(N + 1) ; fact[0] = fact[1] = 1;",
    "    for(int i = 2; i<= N; i++)",
    "        fact[i] = (i*fact[i-1])%mod;",
    "    ifact[N] = modInverse(fact[N] , mod);",
    "    for(int i = N - 1; i>= 0 ; i--)",
    "        ifact[i] = ( (i + 1)*ifact[i + 1])%mod;",
    "}",
    ""
  ], 
  "description": "Factorial"
}
}
